import unittest
from unittest.mock import patch, MagicMock
from core.audio_processor import AudioProcessor
from core.subtitle_parser import SubtitleItem

class TestAudioProcessor(unittest.TestCase):
    def setUp(self):
        # Mock internal TTS logic
        self.mock_tts = MagicMock()
        self.mock_tts.generate_audio.return_value = True
        self.processor = AudioProcessor(self.mock_tts)
    
    @patch('core.audio_processor.AudioSegment')
    @patch('core.audio_processor.os.path.exists', return_value=True)
    def test_process_padding_when_audio_is_short(self, mock_exists, mock_audio_segment):
        # Mock the segment duration to be shorter than Subtitle duration
        mock_segment = MagicMock()
        mock_segment.__len__.return_value = 1000  # 1 second audio generated by TTS
        
        mock_audio_segment.from_wav.return_value = mock_segment
        mock_audio_segment.silent.return_value = mock_segment
        
        # Subtitle wants 2000 ms duration
        subtitles = [
            SubtitleItem(index=1, start_time_ms=0, end_time_ms=2000, duration_ms=2000, text="Test padding")
        ]
        
        self.processor.process_subtitles(subtitles, temp_dir="/tmp", max_speed=1.5)
        
        # It should calculate diff: 2000 target - 1000 generated = 1000 diff padded silent track
        mock_audio_segment.silent.assert_any_call(duration=1000)

    @patch('core.audio_processor.AudioSegment')
    @patch('core.audio_processor.os.path.exists', return_value=True)
    @patch('core.audio_processor.subprocess.run')
    def test_process_atempo_when_audio_is_long(self, mock_run, mock_exists, mock_audio_segment):
        # Mock the segment duration to be longer than Subtitle duration
        mock_segment = MagicMock()
        mock_segment.__len__.return_value = 3000  # 3 seconds audio generated by TTS
        mock_segment.__add__.return_value = mock_segment  # For concatenation compatibility
        mock_segment.__getitem__.return_value = mock_segment # For slicing segment[:target_dur]
        
        mock_audio_segment.from_wav.return_value = mock_segment
        mock_audio_segment.silent.return_value = mock_segment
        
        # Subtitle wants only 2000 ms duration
        subtitles = [
            SubtitleItem(index=1, start_time_ms=0, end_time_ms=2000, duration_ms=2000, text="Test padding")
        ]
        
        self.processor.process_subtitles(subtitles, temp_dir="/tmp", max_speed=1.5)
        
        # Required speed ratio is 3000 / 2000 = 1.5, which does not exceed max_speed.
        # It should run ffmpeg atempo
        self.assertTrue(mock_run.called)
        args_ffmpeg = mock_run.call_args[0][0]
        self.assertIn('atempo=1.5', args_ffmpeg)

if __name__ == '__main__':
    unittest.main()
